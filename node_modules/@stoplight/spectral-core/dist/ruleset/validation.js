"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertValidRule = exports.isValidRule = exports.assertValidRuleset = exports.RulesetValidationError = void 0;
const tslib_1 = require("tslib");
const ajv_1 = (0, tslib_1.__importStar)(require("ajv"));
const ajv_formats_1 = (0, tslib_1.__importDefault)(require("ajv-formats"));
const ajv_errors_1 = (0, tslib_1.__importDefault)(require("ajv-errors"));
const json_1 = require("@stoplight/json");
const spectral_runtime_1 = require("@stoplight/spectral-runtime");
const ruleSchema = (0, tslib_1.__importStar)(require("../meta/rule.schema.json"));
const rulesetSchema = (0, tslib_1.__importStar)(require("../meta/ruleset.schema.json"));
const shared = (0, tslib_1.__importStar)(require("../meta/shared.json"));
const message = (0, ajv_1._) `'spectral-message'`;
const ajv = new ajv_1.default({ allErrors: true, strict: true, strictRequired: false, keywords: ['$anchor', 'x-internal'] });
(0, ajv_formats_1.default)(ajv);
(0, ajv_errors_1.default)(ajv);
ajv.addKeyword({
    keyword: 'spectral-runtime',
    schemaType: 'string',
    error: {
        message(ctx) {
            return (0, ajv_1._) `${ctx.data}[Symbol.for(${message})]`;
        },
    },
    code(cxt) {
        const { data } = cxt;
        switch (cxt.schema) {
            case 'spectral-format':
                cxt.fail((0, ajv_1._) `typeof ${data} !== "function"`);
                break;
            case 'spectral-function':
                cxt.pass((0, ajv_1._) `typeof ${data}.function === "function"`);
                cxt.pass((0, ajv_1._) `(() => { try { ${data}.function.validator && ${data}.function.validator('functionOptions' in ${data} ? ${data} : null); } catch (e) { ${data}[${message}] = e.message } })()`);
                break;
        }
    },
});
const validate = ajv.addSchema(ruleSchema).addSchema(shared).compile(rulesetSchema);
class RulesetValidationError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
    }
}
exports.RulesetValidationError = RulesetValidationError;
const RULE_INSTANCE_PATH = /^\/rules\/[^/]+/;
const GENERIC_INSTANCE_PATH = /^\/(?:aliases|extends|overrides(?:\/\d+\/extends)?)/;
class RulesetAjvValidationError extends RulesetValidationError {
    constructor(ruleset, errors) {
        super(RulesetAjvValidationError.serializeAjvErrors(ruleset, errors));
        this.ruleset = ruleset;
        this.errors = errors;
    }
    static serializeAjvErrors(ruleset, errors) {
        const sortedErrors = [...errors]
            .sort((errorA, errorB) => {
            const diff = errorA.instancePath.length - errorB.instancePath.length;
            return diff === 0 ? (errorA.keyword === 'errorMessage' && errorB.keyword !== 'errorMessage' ? -1 : 0) : diff;
        })
            .filter((error, i, sortedErrors) => i === 0 || sortedErrors[i - 1].instancePath !== error.instancePath);
        const filteredErrors = [];
        l: for (let i = 0; i < sortedErrors.length; i++) {
            const error = sortedErrors[i];
            const prevError = i === 0 ? null : sortedErrors[i - 1];
            if (GENERIC_INSTANCE_PATH.test(error.instancePath)) {
                let x = 1;
                while (i + x < sortedErrors.length) {
                    if (sortedErrors[i + x].instancePath.startsWith(error.instancePath) ||
                        !GENERIC_INSTANCE_PATH.test(sortedErrors[i + x].instancePath)) {
                        continue l;
                    }
                    x++;
                }
            }
            else if (prevError === null) {
                filteredErrors.push(error);
                continue;
            }
            else {
                const match = RULE_INSTANCE_PATH.exec(error.instancePath);
                if (match !== null && match[0] !== match.input && match[0] === prevError.instancePath) {
                    filteredErrors.pop();
                }
            }
            filteredErrors.push(error);
        }
        return filteredErrors
            .map(({ message, instancePath }) => `Error at ${(0, spectral_runtime_1.printPath)(instancePath.slice(1).split('/'), spectral_runtime_1.PrintStyle.Pointer)}: ${message !== null && message !== void 0 ? message : ''}`)
            .join('\n');
    }
}
function assertValidRuleset(ruleset) {
    var _a;
    if (!(0, json_1.isPlainObject)(ruleset)) {
        throw new Error('Provided ruleset is not an object');
    }
    if (!('rules' in ruleset) && !('extends' in ruleset) && !('overrides' in ruleset)) {
        throw new RulesetValidationError('Ruleset must have rules or extends or overrides defined');
    }
    if (!validate(ruleset)) {
        throw new RulesetAjvValidationError(ruleset, (_a = validate.errors) !== null && _a !== void 0 ? _a : []);
    }
}
exports.assertValidRuleset = assertValidRuleset;
function isValidRule(rule) {
    return typeof rule === 'object' && rule !== null && !Array.isArray(rule) && ('given' in rule || 'then' in rule);
}
exports.isValidRule = isValidRule;
function assertValidRule(rule) {
    if (!isValidRule(rule)) {
        throw new TypeError('Invalid rule');
    }
}
exports.assertValidRule = assertValidRule;
//# sourceMappingURL=validation.js.map